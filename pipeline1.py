# -*- coding: utf-8 -*-
"""pipeline1v3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HCJAcJvVnTfdFMy_bKPgU94bd75PYSif

**Pipeline for extracting coordinates**

In this notebook, it receives an image or images of WSI and gives you the coordinates of all the cells. The cells are extracted by using segmentation from the cellpose library.
"""

import numpy as np
import time, os, sys
from urllib.parse import urlparse
import skimage.io
import matplotlib.pyplot as plt
import matplotlib as mpl
# %matplotlib inline
mpl.rcParams['figure.dpi'] = 300

from urllib.parse import urlparse
from cellpose import models, core

use_GPU = core.use_gpu()
print('>>> GPU activated? %d'%use_GPU)

# call logger_setup to have output of cellpose written
from cellpose.io import logger_setup
logger_setup();

#IMPORTS
from tifffile import imread, imwrite   #read the svs image
import numpy as np    #numpy
from skimage.color import rgb2gray    #turn image to grayscale
from cellpose import models
from cellpose import plot
from cellpose import transforms
from cellpose import utils
import matplotlib.patches as patches
import csv
import random
import cv2

#Special imports tp read the configuration file
import sys
sys.path.append("C:/Users/user/Documents/Hilsia_Rivka/Dream/MSc/research/usefulNotebooks/finals")
#import the configuration file
import pipelines_config_v2 as config
p = config.p


# Get the WSI image path and output directory dynamically
if len(sys.argv) < 3:
    raise ValueError("Usage: python pipeline1v4.py <wsi_image_path> <output_dir>")

wsi_img_path = sys.argv[1]  # WSI image path
output_dir = sys.argv[2]    # Output directory

# Ensure output directory exists
os.makedirs(output_dir, exist_ok=True)

#Function to read the image
def readIMG(path):
  #my computer can read only up to size about 10M
  img = imread(path)
  return img

#function to print the original image
def printIMG(image):
  plt.imshow(image)

#Function to divide the WSI image
def divide_image_with_overlap_and_coordinates(image, subset_size, overlap):
    subsets = []
    subset_coordinates = []
    intensities = []
    cols, rows, _ = image.shape
    subset_rows, subset_cols, _ = subset_size
    overlap_rows, overlap_cols, _ = overlap

    # Calculate the number of subsets needed to cover the image
    num_rows = (rows) // (subset_rows - overlap_rows) + 1
    num_cols = (cols) // (subset_cols - overlap_cols) + 1   # - subset_cols

    # Add padding to the image if necessary
    padded_rows = num_rows * (subset_rows - overlap_rows) + overlap_rows
    padded_cols = num_cols * (subset_cols - overlap_cols) + overlap_cols
    pad_rows = max(0, padded_rows - rows)
    pad_cols = max(0, padded_cols - cols)
    padded_image = np.pad(image, ((0, pad_rows), (0, pad_cols), (0, 0)), mode='constant')

    for i in range(num_rows):
        for j in range(num_cols):
            start_row = i * (subset_rows - overlap_rows)  # Calculate the starting position of the subset
            start_col = j * (subset_cols - overlap_cols)
            subset = padded_image[ start_col:start_col+subset_cols, start_row:start_row+subset_rows,:]
            gray = cv2.cvtColor(subset, cv2.COLOR_RGB2GRAY)  # Convert to grayscale
            mean_intensity = np.mean(gray)
            if 125 < mean_intensity < 175:
                subsets.append(subset)
                ymin = start_row
                ymax = start_row + subset_rows
                xmin = start_col
                xmax = start_col + subset_cols
                subset_coordinates.append((xmin, xmax, ymin, ymax))   # Store the coordinates of the subset
    print("number of subsets are: ", len(subsets))
    return subsets, subset_coordinates

# RUN CELLPOSE FOR SEGMENTATION
def segmentation(image, model_name, channels_type):
  if model_name == 'cyto':
    model = models.CellposeModel(gpu=use_GPU, model_type='cyto')
  if model_name == 'nuclei':
    model = models.CellposeModel(gpu=use_GPU, model_type='nuclei')
  channels = channels_type
  masks, flows, styles = model.eval(image, diameter=None, flow_threshold=None, channels=channels)
  return masks, flows, styles

#Function to create list of cell in the current mask of the image
def make_cell_list(masks):
  list_cells = utils.outlines_list_single(masks)
  return list_cells

#First function to calculate min max of single cell

def extract_cells(cell_mask_list):
    cells = []
    for i in range(len(cell_mask_list)):
      desired_masks = cell_mask_list[i]
      mask_array = np.array(desired_masks)  # Convert the list to a NumPy array for easier manipulation
      if mask_array.size != 0:
          min_x, min_y = np.min(mask_array, axis=0)  # Find the minimum and maximum values along the x and y axes
          max_x, max_y = np.max(mask_array, axis=0)
          cells.append({'cell_number': i, 'x_min': min_x, 'y_min': min_y, 'x_max': max_x, 'y_max': max_y})
    return cells

#B,H this block of code is working
##This block of code prints the images from the file. If there is less images than 3 then print all of the images, if there is more than 3 then print random 3

def print_img(directory_path):
  file_paths = [os.path.join(directory_path, filename) for filename in os.listdir(directory_path)]
  if len(file_paths) > 3: # Select three random images if there are more than three, otherwise select all
      selected_files = random.sample(file_paths, 3)
  else:
      selected_files = file_paths
  # Display the selected images
  plt.figure(figsize=(10, 10))
  for i, file_path in enumerate(selected_files):
      img = readIMG(file_path)
      plt.subplot(1, len(selected_files), i + 1)
      printIMG(img)
  plt.show()

#print_img(path}) #This line prints out few images of the images submitted

#This block of code takes in images and gives out the coordinates of each cells from each images into a csv file
def record_coords(output_directory, wsi_image_path, limitNumCells):
  num_file = 1
  output_directory = output_dir  # Define the output directory
  if not os.path.exists(output_directory):  # Check if the output directory exists, if not create it
      os.makedirs(output_directory)
  # Define the file name and full path in the output directory
  file_name = os.path.join(output_directory, "coords_cells.csv")  # Save as 'coords_cells.csv' in the output directory
  
  img = readIMG(wsi_image_path)
  print ("img shape is:", img.shape)
  
  initial_data = [['Cell number', 'min x', 'max x', 'min y', 'max y']]
  with open(file_name, mode='w', newline='') as file:
    writer = csv.writer(file)
    writer.writerows(initial_data)
  subset_size =p["subset_size"]    #from configuration file
  overlap = p["overlap"]    #from configuration file
  if img.shape[0] > 400:
    subsets, subset_coordinates = divide_image_with_overlap_and_coordinates(img, subset_size, overlap)
  else:
    subsets = [img]
  print("subsets length: ", len(subsets))
  cell_num = 1
  stop_processing = False  # flag to stop the loop as soon as it reaches 40k cells
  processed_subsets = set()
  while cell_num <= limitNumCells and len(processed_subsets) < len(subsets):
      i = random.choice([idx for idx in range(len(subsets)) if idx not in processed_subsets])
      processed_subsets.add(i)
      masks, flows, _ = segmentation(subsets[i], 'cyto', [0, 0])
      cells_list_in_mask = make_cell_list(masks)
      info_cells = extract_cells(cells_list_in_mask)
      min_yPixel_img = subset_coordinates[i][0]
      min_xPixel_img = subset_coordinates[i][2]
      for j in range(len(info_cells)):
          min_x_cell = info_cells[j]['x_min']
          min_y_cell = info_cells[j]['y_min']
          max_x_cell = info_cells[j]['x_max']
          max_y_cell = info_cells[j]['y_max']
          x_min_cell = min_xPixel_img + min_x_cell
          x_max_cell = min_xPixel_img + max_x_cell
          y_min_cell = min_yPixel_img + min_y_cell
          y_max_cell = min_yPixel_img + max_y_cell
          if cell_num > limitNumCells:
              stop_processing = True
              break
          cell_data = [[cell_num, x_min_cell, x_max_cell, y_min_cell, y_max_cell]]
          with open(file_name, mode='a', newline='') as file:
              writer = csv.writer(file)
              writer.writerows(cell_data)
          cell_num += 1
      if stop_processing:
          break
  print(f"Number of subsets used: {len(processed_subsets)}")
  num_file += 1

path = wsi_img_path
limitNumCells = p["limitNumCells"]
record_coords(output_dir, wsi_img_path, limitNumCells) #This line call the record_coords function
print("Notebook 1 has run successfully")